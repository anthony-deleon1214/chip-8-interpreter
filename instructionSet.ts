// Array of opcode objects
// Types: 'A' = 'Address', 'R' = 'Register', 'NN' = 'Hex byte', 
const instructions = [
    {
        id: CLR,
        name: CLR,
        description: 'Clear screen',
        mask: 0xFFFF,
        pattern: 0x00E0,
        arguments: [],
    },
    {
        id: RET,
        name: RET,
        description: 'Return from a subroutine',
        mask: 0xFFFF,
        pattern: 0x00EE,
        arguments: [],
    },
    {
        id: JP_ADDR,
        name: JP_ADDR,
        description: 'Jump to address NNN',
        mask: 0xF000,
        pattern: 0x1000,
        arguments: [{ mask: 0x0FFF, shift: 0, type: 'A' }],
    },
    {
        id: CALL_ADDR,
        name: CALL_ADDR,
        description: 'Execute subroutine at address NNN',
        mask: 0xF000,
        pattern: 0x2000,
        arguments: [{ mask: 0x0FFF, shift: 0, type: 'A' }],
    },
    {
        id: SE_VX_NN,
        name: SE,
        description: 'Skip next instruction if VX value equals NN',
        mask: 0xF000,
        pattern: 0x3000,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00FF, shift: 0, type: 'NN' }],
    },
    {
        id: SNE_VX_NN,
        name: SNE,
        description: 'Skip next instruction if VX not equal to NN',
        mask: 0xF000,
        pattern: 0x4000,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00FF, shift: 0, type: 'NN' }],
    },
    {
        id: SE_VX_VY,
        name: SE_VX_VY,
        description: 'Skip next instruction if VX equal to VY',
        mask: 0xF00F,
        pattern: 0x5000,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: STO_NN_VX,
        name: STO_NN_VX,
        description: 'Store value NN in register VX',
        mask: 0xF000,
        pattern: 0x6000,
        arguments: [{ mask: 0x0FF0, shift: 4, type: 'NN' }, { mask: 0x000F, shift: 0, type: 'R' }],
    },
    {
        id: ADD_NN_VX,
        name: ADD_NN_VX,
        description: 'Add value NN to register VX',
        mask: 0xF000,
        pattern: 0x7000,
        arguments: [{ mask: 0x0FF0, shift: 4, type: 'NN' }, { mask: 0x000F, shift: 0, type: 'R' }],
    },
    {
        id: STO_VY_VX,
        name: STO_VY_VX,
        description: 'Store the value in VY in VX',
        mask: 0xF000,
        pattern: 0x8000,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: VX_OR_VY,
        name: VX_OR_VY,
        description: 'Set VX to VX OR VY',
        mask: 0xF00F,
        pattern: 0x8001,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: VX_AND_VY,
        name: VX_AND_VY,
        description: 'Set VX to VX AND VY',
        mask: 0xF00F,
        pattern: 0x8002,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: VX_XOR_VY,
        name: VX_XOR_VY,
        description: 'Set VX to VX XOR VY',
        mask: 0xF00F,
        pattern: 0x8003,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: ADD_VY_VX,
        name: ADD_VY_VX,
        description: 'Add VY to VX, set VF to 01 if carry is required, 00 otherwise',
        mask: 0xF00F,
        pattern: 0x8004,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: SUB_VY_VX,
        name: SUB_VY_VX,
        description: 'Subtract VY from VX, set VF to 00 if borrow occurs, 01 otherwise',
        mask: 0xF00F,
        pattern: 0x8005,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: SHR_VY_VX,
        name: SHR,
        description: 'Store value in VY shifted right one bit in VX, VY is unchanged, set VF to LSB prior to shift',
        mask: 0xF00F,
        pattern: 0x8006,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: SUBX_VX_VY,
        name: SUBX,
        description: 'Set VX to the value of VY minus VX, set VF to 00 if borrow occurs, 01 otherwise',
        mask: 0xF00F,
        pattern: 0x8007,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: SHL_VY_VX,
        name: SHL,
        description: 'Store value in VY shifted left one bit in VX, VY is unchanged, set VF equal to MSB prior to shift',
        mask: 0xF00F,
        pattern: 0x800E,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: SNE_VX_VY,
        name: SNE,
        description: 'Skip next instruction if VX is not equal to VY',
        mask: 0xF00F,
        pattern: 0x9000,
        arguments: [{ mask: 0x0F00, shift: 8, type: 'R' }, { mask: 0x00F0, shift: 4, type: 'R' }],
    },
    {
        id: STO_NNN_I,
        name: STO,
        description: 'Store memory address NNN in register I',
        mask: 0xF000,
        pattern: 0xA000,
        arguments: [{ mask: 0x0FFF, shift: 0, type: 'NNN' }],
    },
    {
        id: JMP_V0,
        name: JMP,
        description: 'Jump to memory address NNN + V0',
        mask: 0xF000,
        pattern: 0xB000,
        arguments: [{ mask: 0x0FFF, shift: 0, type: 'NNN'}],
    },
    {
        
    }
]